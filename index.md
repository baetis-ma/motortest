## Simple Web Page
<img align="right" width="45%" height="350" src="helloworld.png"></img>
#####  A project is decribed that uses a webpage to control a test of a motor with a propellor. The esp hosts a webpage allowing :
```
- power relay to the motor on/off
- frequency of esc pulses
- pwm pulse width to esc control
- rotation speed of motor
- thrust measured by strain guage
- current being used by esc
- voltage into esc
```
##### The webpage shot to the right shows the responce and control fields assisting this test. The webpage is loaded when session is started and remains resident. The index.html embeds javascript code that responds to actions initiated by the user clicking or entering action fields on the browser display and in responce generates a tcp packet with a resource field of `GET /trfData?vout=0x40+pwm=1222+freq=50+onoff=0`. The javascript as responds to the return packet from the esp in the form `data,3.0960,3.8640,4.6320,5.4000,0.000000,inf,`, this is the data being collected from ADCs and a pulse counter on the esp, the javascript parses this data and updates the diplay with rev/min, power, voltage and weight measurements.
##### Using curl commands in a shell (or perl) script allows programmatic control of motor testing, where the pwm can be adjusted upward slowly and the motor speed, motor power and generated thrust can be saved to a file and studied with gnuplot afterward.
##### This project sets up a simple tcp socket with enough functionality to serve up a stand-alone .html file and handle bi-directional data flow between the esp device and the browser.
##### The tcp_server_task in the esp takes the incoming IP packets combines, windows, verifies/requests retransmission, and notifies us that an http request is ready. When I filled 192.168.0.122/index.html into my browser address bar window the contents of the tcp server (running over in my esp running a wifi connection at IP adrress 192.168.0.122) receive buffer were:
```
GET /trfData?vout=0x40+pwm=1300+freq=50+onoff=0 HTTP/1.1
Host: 192.168.0.106
Connection: keep-alive
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.51 Safari/537.36
Content-Type: application/bin
Accept: */*
Referer: http://192.168.0.106/index.html
Accept-Encoding: gzip, deflate
Accept-Language: en-US,en;q=0.9,la;q=0.8



voltage =  3.0960  3.8640  4.6320  5.4000  rps= 0.000000  pwm=   inf throttle=  1300

curl --http0.9 192.168.0.106/trfData?pwm=1250 --output -
data,3.0960,3.8640,4.6320,5.4000,0.000000,inf,

```
##### The esp programs tcp_sever_task examines the incoming packet and extracts parameters url_type, url_name and url_resource. In the above packet the parameters extracted would be url_type = ‘GET’ and url_name = ‘index.html’ and url_resource is empty, this packet was sent from browser request 192.168.0.122/index.html in the serch bar. The program figures out that this is a request of the contents of the file ‘index.html’ (stored in esp eprom) and forwards it to the tcp server socket send command. The browser executes the data returning from this request will be executed as html.
<img align="right" width="45%" height="350" src="helloworld0.png"></img>
##### The browser request 192.168.0.122/getData?hello+world tcp_server_task extracts url_name = 'getData' and url_resource = 'hello+world'. The top level subroutine getData() is called - which generated a simple web page output to the socket back to the browser. The url_resource string can be parsed to transfer state from the brower to the esp. The esp can respond in the webpage trnsmitting esp state back to the browser. The browser command above can also be generated by the html code with action commands.
##### If neither of the above url_type/url_name conditions are not matched the esp returns a simple 404 page.
##### The entire top level `website.c` program is shown below, the main portion of the program starts the `nvs_flash_init()` (where the index.html file is stored) and then `initialize_wifi()` and `wait_for_ip()` (initialize and wait for ip connection). The program then starts `xTaskCreate(tcp_server_task, "tcp_server", 8192, NULL, 4, NULL)` which sets up socket to listen for tcp connection, then reading and parsing that packet. The `tcp_server_task` will take action based on these results, either serving up index.html page, dumping a 404 page or running the subroutine GetData in website.c. In this case all the GetData subroutine does is make a simple html responce to the client browser.
`

## Setting up
##### Another earlier repository https://baetis-ma.github.io/esp32-idf-website/ goes through setting up another very similar project with out the javascript. 
